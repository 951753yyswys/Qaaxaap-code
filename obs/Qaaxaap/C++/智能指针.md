# 页面介绍

本页简单介绍几种 C++ 风格的智能指针，能看就行的那种。

# 共享指针 - `shared_ptr`

`shared_ptr` 是允许一个对象被多个指针拥有的指针，并且支持自动释放内存。

本质原理是使用了一个额外的计数器块，对于每一个对象记录被指向的次数，若归零自动释放。

也因此，它的时间常数开销大约是传统指针的 $2$ 倍左右

使用：

```cpp
shared_ptr<int> a=make_shared<int>(114514);
shared_ptr<int> b=nullptr;
```

# 独占指针 - `unique_ptr`

`unique_ptr` 是一个经过封装的传统指针，具有 RAII 安全，并且可以自动释放内存。

其与 `shared_ptr` 的区别是它不能由多个指针共享同一个对象，也不支持复制操作，只可以将一个指针的对象移动给另一个指针，原指针变成 `nullptr`。

使用：

```cpp
unique_ptr<int> a=make_unique<int>(114514);
unique_ptr<int> b=nullptr;
b=move(a);
```

由于其封装的效率很高，而且没有额外的计数器块，所以常数很小，和传统指针相当。

一般情况下，最建议使用 `unique_ptr`，最常用的一般也是 `unique_ptr`。

另外，`unique_ptr` 有一些好用的小操作，比如用一个非 `const` 变量来定义数组，并不比 `vector` 慢，另外还比较省空间。

```cpp
int n;
cin>>n;
unique_ptr<int[]> a=make_unique<int[]>(n);
```

并且，这样的数组是使用的堆空间而非栈空间，这样也不容易导致栈溢出。

# 弱引用指针 - `weak_ptr` 

有时候，我们需要将两个 `shared_ptr` 互相指向，例如在记录一棵二叉树的时候

```cpp
struct tree
{
	shared_ptr<tree> fa,l,r;
	tree(shared_ptr<tree> f){fa=f,l=r=nullptr;}
};
```

但是这会导致两个 `shared_ptr` 互相引用，而按照它的原理，这会导致计数器块永远不会降低为 $0$，这样内存永远不会被释放，然后就内存溢出了。

所以为了打破循环引用，我们需要一个不会增加计数器块的共享指针。

所以，这就是 `weak_ptr`，在使用的时候所指向的对象的计数器块不会增加，可以打破循环引用。

但是这么做的话，就需要稍微麻烦一些。

因为 `weak_ptr` 不拥有对象，所以在使用时，需要使用 `lock()` 创建一个临时的 `shared_ptr` 来临时拥有。

```cpp
struct tree
{
	shared_ptr<tree> l,r;
	weak_ptr<tree> fa;
	tree(shared_ptr<tree> f){fa=f,l=r=nullptr;}
};
tree a(/*something*/);
void work()
{
	shared_ptr<tree> fa=a.fa.lock();//此时，fa 指向 a 的父节点，但是若已经被销毁，则是 nullptr
	if(fa==nullptr) return;
	/*
	do something
	*/
}
```